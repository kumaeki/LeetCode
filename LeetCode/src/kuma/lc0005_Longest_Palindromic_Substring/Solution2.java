package kuma.lc0005_Longest_Palindromic_Substring;

import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.Test;

public class Solution2 {
    char[] charArr;
    int len, canL, canR;

    public String longestPalindrome(String s) {
        if (s == null || s.length() == 0)
            return s;

        len = s.length();
        charArr = s.toCharArray();
        canL = 0;
        canR = 0;

        for (int i = 0; i < len; i++) {
            isPalindrome(i, i + 1);
            isPalindrome(i - 1, i + 1);
        }

        return s.substring(canL, canR + 1);
    }

    public void isPalindrome(int left, int right) {
        for (int i = left, j = right; i >= 0 && j < len; i--, j++) {
            if (charArr[i] != charArr[j])
                break;
            else if (j - i > canR - canL) {
                canL = i;
                canR = j;
            }
        }
    }

    @Test
    public void testSimple1() {
        String expected = "bab";
        String actual = new Solution2().longestPalindrome("babad");
        assertEquals(expected, actual);
    }

    @Test
    public void testSimple2() {
        String expected = "bb";
        String actual = new Solution2().longestPalindrome("cbbd");
        assertEquals(expected, actual);
    }

    @Test
    public void testSimple3() {
        String expected = "";
        String actual = new Solution2().longestPalindrome("");
        assertEquals(expected, actual);
    }

    @Test
    public void testSimple4() {
        String expected = "321012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210123";
        String actual = new Solution2().longestPalindrome(
                "321012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210123210012321001232100123210123");
        assertEquals(expected, actual);
    }
}
